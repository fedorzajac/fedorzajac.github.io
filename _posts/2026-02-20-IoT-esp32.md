---
layout: post
title:  "ðŸ•¸ï¸ Internet of Things: ESP32, MicroPython, and the Art of Making LEDs Blink"
date:   2026-02-20 20:47:40 +0100
categories: mqtt micropython esp32
---

I bought a microcontroller.

Not my first one. Probably not the last one either.
But this time itâ€™s **ESP32** â€” a tiny piece of silicon that somehow manages to squeeze in Wi-Fi, Bluetooth, enough GPIOs to get you into trouble, and just enough documentation to keep things interesting.

ESP32 is one of those chips that quietly became *the* default choice for hobby IoT: cheap, powerful, well-supported, and forgiving enough that you can flash it a dozen times without bricking it (usually).


## Why ESP32 + MicroPython?

Because life is too short to write C for blinking LEDs.

MicroPython gives you a Python 3â€“like environment running **directly on the microcontroller**. No OS, no containers, no systemd â€” just you, bare metal, and a REPL. It feels wrong in the best possible way.

To make this work, we need to flash MicroPython firmware onto the ESP32.

## Getting the firmware

The official MicroPython builds live here:

- https://micropython.org/download/ESP32_GENERIC/

For this setup, I used:

- https://micropython.org/resources/firmware/ESP32_GENERIC-20251209-v1.27.0.bin

Yes, itâ€™s just a `.bin` file. No installer. No wizard. No safety net.

## Connecting the board

Plug the ESP32 into your computer via USB.
Now find out what device name it got assigned:

```bash
ls /dev/cu.*
```
Youâ€™re looking for something like usbserial, SLAB_USBtoUART, or similarly cryptic poetry.

## Flashing MicroPython onto the ESP32

First, install the flashing tool:
```bash
pip3 install esptool
```
Itâ€™s a good idea to wipe the flash completely (clean slate, clean conscience):
```bash
esptool.py --port /dev/cu.usbserial-110 erase_flash
```
Now flash the firmware:
```bash
esptool.py --chip esp32 \
  --port /dev/cu.usbserial-110 \
  --baud 460800 \
  write_flash -z 0x1000 ESP32_GENERIC-20251209-v1.27.0.bin
```
If this succeeds, your ESP32 has officially stopped being a dumb piece of hardware and started being a programmable one.

Talking to the ESP32 (REPL mode)

To communicate with MicroPython, install mpremote:
```bash
pip3 install mpremote
```
Connect to the board and open the REPL:
```bash
mpremote connect /dev/cu.SLAB_USBtoUART repl
```
If you see (yuo might hit `enter` along the way):
```bash
>>>
```
Youâ€™re in.
This is a live Python prompt running on a microcontroller. Let that sink in.

Useful commands youâ€™ll need sooner than you think:

```bash
# List files on the ESP32:
mpremote ls
# Remove a file:
mpremote rm file.py
```
## The obligatory blinking LED

No embedded journey is complete without a blinking LED.
This one uses GPIO 2, which is usually connected to the onboard LED on ESP32 dev boards.

Create main.py:
```bash
from machine import Pin
from time import sleep

led = Pin(2, Pin.OUT)

while True:
    led.value(1)
    sleep(0.5)
    led.value(0)
    sleep(0.5)
```
Upload it to the ESP32:
```bash
mpremote connect /dev/cu.usbserial-110 fs cp main.py :
```
`main.py` is special: it runs automatically on boot.
Power-cycle the board, and the LED starts blinking without asking for permission.

## Bonus - Distance sensor

```python
from machine import Pin, time_pulse_us
import time

trig = Pin(5, Pin.OUT)
echo = Pin(18, Pin.IN)

def distance_cm():
    # send 10us impulse
    trig.off()
    time.sleep_us(2)
    trig.on()
    time.sleep_us(10)
    trig.off()

    # measure echo
    duration = time_pulse_us(echo, 1, 30000)  # timeout 30ms

    if duration < 0:
        return None  # no measure

    # calculation: sound ~343 m/s
    dist = (duration / 2) * 0.0343
    return dist

while True:
    d = distance_cm()
    if d is None:
        print("Out of range")
    else:
        print("Distance:", round(d, 1), "cm")
    time.sleep(0.5)
```
